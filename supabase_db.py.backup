"""
Supabase Database Integration
Cloud PostgreSQL database for persistent storage
"""
import streamlit as st
import pandas as pd
import datetime
import json
from typing import Optional, Dict, Any, List

try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False

class SupabaseManager:
    """Manage Supabase database operations"""
    
    def __init__(self):
        self.supabase: Optional[Client] = None
        self.table_name = "collected_data"
        self._initialize()
    
    def _initialize(self):
        """Initialize Supabase client"""
        if not SUPABASE_AVAILABLE:
            return
        
        try:
            # Get credentials from Streamlit secrets
            url = st.secrets.get("SUPABASE_URL", "")
            key = st.secrets.get("SUPABASE_ANON_KEY", "")
            
            if url and key:
                self.supabase = create_client(url, key)
                self._create_table_if_not_exists()
            else:
                st.warning("🔑 Supabase credentials not found in secrets. Please configure SUPABASE_URL and SUPABASE_ANON_KEY")
        except Exception as e:
            st.error(f"❌ Failed to initialize Supabase: {str(e)}")
    
    def _create_table_if_not_exists(self):
        """Create the table if it doesn't exist"""
        if not self.supabase:
            return
        
        try:
            # Check if table exists by trying to count rows
            response = self.supabase.table(self.table_name).select("id", count="exact").limit(1).execute()
            st.success(f"✅ Connected to Supabase! Table '{self.table_name}' is ready.")
        except Exception as e:
            # Table might not exist, show instructions to create it
            st.warning(f"""
            🏗️ **Table Setup Required**
            
            Please create the table in your Supabase database:
            
            1. Go to your Supabase dashboard
            2. Navigate to Table Editor
            3. Create a new table named `{self.table_name}` with these columns:
            
            ```sql
            CREATE TABLE {self.table_name} (
                id BIGSERIAL PRIMARY KEY,
                timestamp TIMESTAMPTZ DEFAULT NOW(),
                data_type TEXT NOT NULL,
                filename TEXT NOT NULL,
                category TEXT,
                description TEXT,
                tags TEXT,
                file_size BIGINT,
                original_name TEXT,
                duration REAL,
                resolution TEXT,
                latitude REAL,
                longitude REAL,
                city TEXT,
                region TEXT,
                country TEXT,
                location_method TEXT,
                additional_info JSONB,
                file_data BYTEA,
                mime_type TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            );
            ```
            
            Or use the SQL Editor in Supabase to run this command.
            """)
    
    def is_available(self) -> bool:
        """Check if Supabase is available and configured"""
        return SUPABASE_AVAILABLE and self.supabase is not None
    
    def save_data(self, data_type: str, filename: str, file_data: bytes = None, 
                  additional_info: Dict = None, location_data: Dict = None) -> Optional[int]:
        """Save data to Supabase"""
        if not self.is_available():
            return None
        
        try:
            # Skip Supabase Storage for now due to permission issues
            # Save file locally and store metadata in database
            file_url = None
            
            # For now, just store metadata - files are saved locally by the calling function
            # Once storage permissions are fixed by admin, this can be re-enabled
            
            # Prepare data for insertion (metadata + file URL if uploaded)
            record = {
                "timestamp": datetime.datetime.now().isoformat(),
                "data_type": data_type,
                "filename": filename,
                "file_data": file_url,  # Store URL instead of binary data
                "mime_type": f"{data_type}/*" if file_data else None
            }
            
            # Add additional info
            if additional_info:
                record.update({
                    "category": additional_info.get("category"),
                    "description": additional_info.get("description"),
                    "tags": ",".join(additional_info.get("tags", [])) if additional_info.get("tags") else None,
                    "file_size": additional_info.get("file_size"),
                    "original_name": additional_info.get("original_name"),
                    "duration": additional_info.get("duration"),
                    "resolution": additional_info.get("resolution"),
                    "additional_info": additional_info
                })
            
            # Add location data
            if location_data:
                if 'coordinates' in location_data:
                    record["latitude"] = location_data['coordinates'].get('latitude')
                    record["longitude"] = location_data['coordinates'].get('longitude')
                record.update({
                    "city": location_data.get('city'),
                    "region": location_data.get('region'),
                    "country": location_data.get('country'),
                    "location_method": location_data.get('detection_method')
                })
            
            # Insert data
            response = self.supabase.table(self.table_name).insert(record).execute()
            
            if response.data:
                # TODO: In the future, we could upload binary files to Supabase Storage
                # For now, we just store metadata and keep files locally
                return response.data[0]['id']
            else:
                return None
                
        except Exception as e:
            st.error(f"❌ Supabase save error: {str(e)}")
            return None
    
    def get_all_data(self) -> pd.DataFrame:
        """Get all data from Supabase"""
        if not self.is_available():
            return pd.DataFrame()
        
        try:
            response = self.supabase.table(self.table_name).select("*").order("created_at", desc=True).execute()
            
            if response.data:
                df = pd.DataFrame(response.data)
                return df
            else:
                return pd.DataFrame()
                
        except Exception as e:
            st.error(f"❌ Supabase fetch error: {str(e)}")
            return pd.DataFrame()
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get database statistics"""
        if not self.is_available():
            return {'total_records': 0, 'type_counts': {}, 'db_size': 0}
        
        try:
            # Get total count
            total_response = self.supabase.table(self.table_name).select("id", count="exact").execute()
            total_records = total_response.count if total_response.count else 0
            
            # Get type counts
            type_response = self.supabase.table(self.table_name).select("data_type").execute()
            type_counts = {}
            if type_response.data:
                for record in type_response.data:
                    data_type = record['data_type']
                    type_counts[data_type] = type_counts.get(data_type, 0) + 1
            
            return {
                'total_records': total_records,
                'type_counts': type_counts,
                'db_size': total_records * 1024  # Rough estimate
            }
            
        except Exception as e:
            st.error(f"❌ Supabase stats error: {str(e)}")
            return {'total_records': 0, 'type_counts': {}, 'db_size': 0}
    
    def delete_record(self, record_id: int) -> bool:
        """Delete a record by ID"""
        if not self.is_available():
            return False
        
        try:
            response = self.supabase.table(self.table_name).delete().eq("id", record_id).execute()
            return True
        except Exception as e:
            st.error(f"❌ Delete error: {str(e)}")
            return False
    
    def update_record(self, record_id: int, updates: Dict[str, Any]) -> bool:
        """Update a record by ID"""
        if not self.is_available():
            return False
        
        try:
            response = self.supabase.table(self.table_name).update(updates).eq("id", record_id).execute()
            return True
        except Exception as e:
            st.error(f"❌ Update error: {str(e)}")
            return False

# Global instance
supabase_manager = SupabaseManager()
